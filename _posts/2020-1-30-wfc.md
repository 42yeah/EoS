---
layout: post
title: Wave Function Collapse
featured: /assets/wfc/wfc-rooms.png
---

Wave Function Collapse is quite a nice algorithm invented by [Maxim Gumin](https://github.com/mxgmn/WaveFunctionCollapse). However, Gumin's source file could be __really__ obscure and hard to understand, so I am writing what I've learned so far here, so that I could remember it when it is needed.

## Introduction

What the hell is Wave Function Collapse, exactly? This is a concept loosely borrowed from Quantum Machanics. I really advise you to watch [this video](https://www.youtube.com/watch?v=PKioZfRw2-Y) if you are interested in that kind of stuffs. But here we are talking about WaveFunctionCollapse, the _PCG (ProCedural Generation) algorithm_. It's usage is quite simple: You feed it an input image, or whatever looks like an image, and it outputs errily similar results. Let's take a look at a few (stolen directly from GitHub repo):

![wfc](/assets/wfc/wfc.png)

Now, isn't this cool? Without all sorts of "machine learning" and stuffs, by only solving the constraints, lots of lively stuffs could appear out of nowhere!

## Try it out

Now, I've implemented one in Javascript. You could play with it for a little bit, however I am not really sure whether my generator could get the same result with Maxim Gumin's or not. Also I will cap N at 3 (Trust me, you browser won't want to go beyond). The color stripe at the bottom is the palatte. Use it to switch colors.

<div>
<canvas id="input" width="500" height="542" style="margin: 1em 0; width: 250px; height: 271px"></canvas>
<canvas id="output" width="500" height="542" style="margin: 1em 0; width: 250px; height: 271px"></canvas>
</div>

<script src="/assets/wfc/main.js" type="module"></script>

N = <input id="n" value="2" type="number" step="1" max="3" min="1"> <a id="generate" href="javascript:void(0)">generate</a> \| <a id="clear" href="javascript:void(0)">clear</a>

## Implementation

Cool, eh? The thing I implement almost works, however it has a major drawback: it is __extremely slow__. Regardless, I think it's worth spending 3 day? Or how many? Looking into sources and stuffs.

This algorithm, down to its heart, is "constraint solving", said by Gumin himself. However, 2D map / texture generation is the most mature usage of this algorithm. It could also be used to generate 3D constructions & poetry, as you can see from its [project page](https://github.com/mxgmn/WaveFunctionCollapse). But without further ado, let's look at the core-est procedure:

```c++
    int main() {
        getInput();
        processInputsIntoLoadsOfPatterns(N);
        initializeOutput();
        while (notFullyCollapsed()) {
            observe();
            propagate();
        } 
    }
```

That's it. In a way, it is quite simple. There might be some word you don't understand there, but don't worry, we'll get to it!

### Getting input

There are lots of ways to get user input. In C++ you might use "stb_image", or if you don't want to use an image (such as if you are a roguelike fan, then why not just cutesy ASCII characters?), you could always implement one yourself. Thus, we are not going to cover this here.

### Processing input into loads of patterns

Now here's an important part. in WFC, patterns are really just a subsection of the original image. This one important parameter, N, stands for pattern size. Such as the thing you drawn above right now (did you)? As its original size is 12x12, if N = 2, there will be at most $$[12 - (N - 1)]^2 = 121$$ patterns. However, additional patterns will be spawned by rotating around the pattern (which I implemented above), and symmetry patterns (which I did not implement).

![Patterns](/assets/wfc/pattern.jpg)

So, the image was chopped up into lots of (overlapping) little pieces; and then, additional patterns are added by transforming these original little pieces. That would be a LOT of little pieces, and certainly we wouldn't want that much. That's why we execute the elimination process at the end; we kill identical patterns, and counting pattern frequency at the same time (as it will be needed later). Using code, it looks a little bit like this:

```c++
for (int y = 0; y <= imageHeight - N; y++) {
    for (int x = 0; x <= imageWidth - N; x++) {
        patterns.add(getImageArea(x, y, N, N), "0deg"); // Add the subimage at (x, y), size (N, N)
        patterns.add(getImageArea(x, y, N, N), "90deg");
        patterns.add(getImageArea(x, y, N, N), "180deg");
        patterns.add(getImageArea(x, y, N, N), "270deg");
    }
}
for (int i = 0; i < patterns.size(); i++) {
    for (int j = i + 1; j < patterns.size(); j++) {
        if (patterns[i] == patterns[j]) { // If the pattern is identical
            patterns[i].frequency++; // Count up the frequency
            patterns.remove(patterns[j]); // Delete the identical twin
            j--; // Go back one, so we don't skip the index
            continue;
        }
    }
}
```

From the code it is not hard to infer that as N goes up, the pattern diversity will increase greatly. And that's why I don't want you to go beyond $$N = 3$$, that's enough to lag your browser.

After pattern generation has been done, we need to begin the _overlap rule recording_ phase. That was called _propagator_ in a number of sources, including Gumin himself. However I find that very confusing, so this is what I am gonna call it. Here you should get what I mean, assuming $$N = 2$$ (stolen shamelessly from a paper):

![Overlaps](/assets/wfc/overlap.png)

Here as we can see, when N = 2, pattern overlapping could be done in 9 ways. We collect the rules about "when those patterns overlaps, their overlap area is the same". So how is that? Allow me to present another figure, still stolen shamelessly from that paper:

![Overlappables](/assets/wfc/overlappable.png)

Let's think about it. When $$(dx, dy) = (0, 0)$$, the only overlappable pattern with the said pattern is __itself__. That makes sense, right? Let's take a look at the figure above, such as when the overlapping pattern is at the original pattern's (-1, -1) direction: we could see that the only overlapped tile is the original pattern's top left corner, which is white; and the overlapping pattern's bottom right corner. Thus, all patterns whose bottom rights are white are allow to overlap with the original pattern, and will be added to the overlapping rules.

After patterns have all been processed, we move onto the next phase: initialize output!

### Initialize output

Of course, initializing output should only be done __after__ pattern generation is complete. 
