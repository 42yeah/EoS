---
layout: post
title: Fruxis Break Down
featured: /assets/fruxis/fruxis.png
---

[Fruxis](https://www.shadertoy.com/view/ldl3zl) by Inigo Quilez is a really, really cool scene. And as I am learning Raymarching (again), this time I will try to break this whole thing down, so to get a little bit advanced-than-before view of raymarching. So, let's go make fruxis again!

## Introduction

There are quite a few objects inside this scene. And as the original author (iq) was using Spanish at that time, let's learn a few Spanish words first:

1. suelo (floor)
2. pared (wall)
3. melon (duh, melon)
4. mazana (apple)
5. uvas (grapes?)
6. lemon
7. jarron (vase)
8. mantelito (doily)
9. botella (bottle)

And we are going to draw it one by one. K, let's begin!

## Implementation

Well first, there's gonna be an empty scene. You can create one at [here](https://www.shadertoy.com/new). Then we need to implement all sorts of basic raymarching functions.

### Intersect

![Raymarching](/assets/shaders/3.jpg)

I don't know if you could remember this, but here's the gist of raymarching: you have a camera, and a direction, and a ray shoots out from the camera, towards the direction. And for every iteration, calculate the nearest object's distance to the ray's head, and the ray advances said distance. If this makes the ray's head ends up in an object (negative distance), the raymarching is done. Otherwise if the ray is going too far or there has been too many iterations already, the raymarching is done.

That's why we need to create the camera first:

```glsl
float an = 2.0 * sin(0.7 + 0.5 * iTime);
vec3 ro = vec3(0.8 + 0.2 * sin(2.0 + an), 0.4, 1.1 + 0.25 * sin(an));
```

We are naming it `ro` because it's a raymarching tradition. `ro` stands for **R**ay **O**rigin and `rd` stands for **R**ay **D**irection. Setting it as the output of the whole graph, and we will see that it sways gently:

```glsl
#version 300 es
precision mediump float;

uniform float time;
in vec2 uv;
out vec4 color;

void main() {
    float an = 2.0 * sin(0.7 + 0.5 * time);
    vec3 ro = vec3(0.8 + 0.2 * sin(2.0 + an), 0.4, 1.1 + 0.25 * sin(an));
    color = vec4(eye, 1.0);
}
```
{% include glsl.html %}

And now, onto the next step! Getting a direction:

```glsl
vec3 center = vec3(-0.2, 0.0, 0.0);
// LookAt matrix
vec3 front = normalize(center - ro);
vec3 right = normalize(cross(front, vec3(0.0, 1.0, 0.0)));
vec3 up = normalize(cross(right, front));

float aspect = iResolution.x / iResolution.y;
vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;
uv.x *= aspect; // multiples aspect so it doesn't lose 

vec3 rd = normalize(uv.x * right + uv.y * up + 2.0 * front);
```

(iq himself really optimzed the variable names and stuffs. If you want to see how he works, check out [here](https://www.shadertoy.com/view/ldl3zl), around line 650.)