---
layout: post
title: Shaders For Beginners
featured: /assets/sfb/cycles.png
---

Shaders are good stuffs. You and I both know that. So today, I think "why don't I go over those shaders and learn something new in the process?", and then began reviewing those old shader knowledges. Well, so this time we are going to talk about all sorts of shaders, most of which are from [here](https://lettier.github.io/3d-game-shaders-for-beginners/index.html). Go check it out!

## Preparations

Well, for gaming shaders to work, a scene is needed. That is why I built one using blender. You can get it [here](/assets/sfb/scene.zip) if you want. It looks just like the featured image: a few balls, and a suzanne overlooking them from the left. First thing first: we are going to create a program and render it! Let's use normals as the output color first:

![normals](/assets/sfb/normals.png)

Well, it's ugly, but you know what's going on. By the way, if you don't know how to get the scene to the screen, check out [LearnOpenGL](https://learnopengl.com/). It's been the most helpful resource if you want to learn. And the first thing we are gonna do is apply the [Phong Reflection Model](https://en.wikipedia.org/wiki/Phong_reflection_model).

## Phong Reflection Model

![Phong components](/assets/sfb/Phong_components_version_4.png)

Ripped straight from Wikipedia, we can see it consists three parts. Ambient, diffuse & specular. But first thing first, we are gonna set the light color! Well, why not just `vec3(1.0, 1.0, 1.0)`? I mean white lights are pretty common, right?

After setting the light color, we can calculate the ambient color first, which is the light color at its very, very dim.

```glsl
vec3 ambient = lightColor * 0.01;
```

This simulates all kinds of photons which bounces around in a random way and reaching the destination. It also means nothing is truly black in the scene. Then, we can begin calculating the diffuse color:

```glsl
vec3 norm = normalize(normal);
vec3 lightDir = normalize(lightPos - pos);
float diff = max(0.0, dot(lightDir, normal));
vec3 diffuse = lightColor * diff;
```

By calculating the dot product of the surface normal and the light direction, here's what we get:

![Cousine product](/assets/sfb/cos.jpg)

The cousine product of the $$\theta$$! Which means when $$\theta$$ gets bigger, the light would be dimmer. Exactly what we want! We want its minimum to be 0.0 though, because if the diff value's negative, it would negate the ambient color, which is not good.

Specular light is quite similar to the diffuse light:

```glsl
vec3 refl = reflect(lightDir, norm);
vec3 eyeDir = normalize(pos - eyePos);
float shinyness = pow(max(0.0, dot(refl, eyeDir)), 16.0);
vec3 specular = lightColor * shinyness;
```

As we can see, it also requires the eye position, that's because specular is for the eyes; it's the sun's reflection on the surface. Diffuse however, is objective and does not really gets affected by the eye. After we get the dot product, we usually power it up by a terrible amount, so the light would really concentrate at one place.

![Specular](/assets/sfb/specular.jpg)

And finally, the object color would be

```glsl
color = vec3((ambient + diffuse + specular) * objectColor)
```

And there you have it:

![Phong](/assets/sfb/phong.png)

## Lighting distance

Well, it looks a little bit too bright. This however, could be swiftly solved by multiplying a `distance` to the output color:

```glsl
float dist = pow(1.0 - (min(5.0, distance(lightPos, pos)) / 5.0), 0.5);
color *= dist;
```

In this way, the further the object is from the light, the dimmer it becomes. The closer, the brighter. And by squaring it, the light dims slower, so it would get a more uniform look:

![Distance](/assets/sfb/distance.png)

## Cel shading

Cel shading makes things look cartoonish by stepping the light color:

![Cartoonish](/assets/sfb/cel.png)

What it does is pretty simple. It is just a slight modification of the Phong shading model, by adding a step procedure after the intensity calculation is done:

```glsl
vec3 lightColor = vec3(1.0, 1.0, 1.0) * 1.0;
vec3 lightPos = vec3(sin(time), 4.0, cos(time)); // Coming from the other way
float dist = pow(1.0 - (min(5.0, distance(lightPos, pos)) / 5.0), 0.5);

// ambient
vec3 ambient = lightColor * 0.01;

// diffuse
vec3 norm = normalize(normal);
vec3 lightDir = normalize(lightPos - pos);
float brightness = max(0.0, dot(lightDir, normal));
brightness = step(0.1, brightness); // Cel shading
vec3 diffuse = lightColor * brightness;

// specular
vec3 refl = reflect(lightDir, norm);
vec3 eyeDir = normalize(pos - eyePos);
float shinyness = pow(max(0.0, dot(refl, eyeDir)), 16.0);
shinyness = step(0.98, shinyness); // Cel
vec3 specular = lightColor * shinyness;
```

In this way, the light transition changes from smooth in Phong shading to abrupt. This adds a cartoonish filter to the scene.

![Graph](/assets/sfb/celgraph.jpg)

## Box blur

Box blur blurs the scene. It is easy, and it gets the job done. I am not using the one from 3DSFB here, but instead I will use the classic box blur from image processing. First, we need to render the scene to a framebuffer, Then render the framebuffer as follow:

```glsl
vec3 boxBlur() {
    // The kernel
    mat3 box = mat3(vec3(1.0, 1.0, 1.0),
                    vec3(1.0, 1.0, 1.0),
                    vec3(1.0, 1.0, 1.0));
    vec3 col = vec3(0.0, 0.0, 0.0);
    for (int y = -1; y <= 1; y++) {
        for (int x = -1; x <= 1; x++) {
            // tex is the framebuffer
            vec3 sample = texture(tex, uv + vec2(x * 0.003, y * 0.003)).xyz;
            col += sample * box[y + 1][x + 1];
        }
    }
    return col / 9.0;
}

void main() {
    vec3 sampled = boxBlur();
    color = vec4(sampled, 1.0);
}
```

![Blur](/assets/sfb/blur.png)

## Fog of war (or just fog)

Fog is an important thing if you don't want the user to see far away stuffs. Its concept is simple: the further the thing is, the higher the intensity the fog is. Then we mix the fog texture with the object color.

```glsl
vec3 fogColor = vec3(0.4, 0.4, 0.4); // I don't have a fog texture, so...
float near = 0.01;
float far = 3.0;
float intensity = clamp((position.y - near) / (far - near), 0.0, 0.95);
vec3 fogged = mix(fogColor, objectColor, min(intensity, 1.0));
```

![Fog](/assets/sfb/fog.png)

Looking down, if the black background doesn't really exist, it feels like the ground is fogged. In game, you oculd just calculate the intensity with the object's distance to the eye. Oooh, why don't we use Perlin Noise to fake noise texture? Here's a hastily written Perlin Noise:

```glsl
float perlin(vec3 p) {
    vec3 u = floor(p);
    vec3 f = fract(p);
    vec3 s = smoothstep(0.0, 1.0, f);
    
    vec3 rands[8];
    rands[0] = rand(u);
    rands[1] = rand(u + vec3(1.0, 0.0, 0.0));
    rands[2] = rand(u + vec3(0.0, 1.0, 0.0));
    rands[3] = rand(u + vec3(1.0, 1.0, 0.0));
    rands[4] = rand(u + vec3(0.0, 0.0, 1.0));
    rands[5] = rand(u + vec3(1.0, 0.0, 1.0));
    rands[6] = rand(u + vec3(0.0, 1.0, 1.0));
    rands[7] = rand(u + vec3(1.0, 1.0, 1.0));

    float res = mix(
        mix(
            mix(dot(rands[0], f), dot(rands[1], f - vec3(1.0, 0.0, 0.0)), s.x),
            mix(dot(rands[2], f - vec3(0.0, 1.0, 0.0)), dot(rands[3], f - vec3(1.0, 1.0, 0.0)), s.x),
            s.y
        ),
        mix(
            mix(dot(rands[4], f - vec3(0.0, 0.0, 1.0)), dot(rands[5], f - vec3(1.0, 0.0, 1.0)), s.x),
            mix(dot(rands[6], f - vec3(0.0, 1.0, 1.0)), dot(rands[7], f - vec3(1.0, 1.0, 1.0)), s.x),
            s.y
        ),
        s.z
    );
    return res;
}
```

Then we can do this with:

```glsl
float r = perlin(pos / 2.0) * 0.5 + 0.5;
vec3 fogged = mix(vec3(r, r, r), o, min(intensity, 1.0));
```

![Perlin](/assets/sfb/perlin.png)

Well, it looks terrible. A little bit like fog, yes, but still terrible. I guess I am just having the wrong parameter. Tweak it yourself!
